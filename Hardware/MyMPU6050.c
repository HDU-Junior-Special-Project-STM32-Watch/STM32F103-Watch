/********************************************************************************************************************
* [菜单]MPU6050界面
********************************************************************************************************************/

#include "stm32f10x.h"

#include "OLED.h"
#include "Key.h"
#include "Delay.h"

#include "MPU6050.h"
#include "MahonyAHRS.h"
#include "param_config.h"
#include <math.h>

#define pi		(3.14159265f)


/*******************************************************************************************************************/
/*[S] 界面样式 [S]-------------------------------------------------------------------------------------------------*/
/*******************************************************************************************************************/

volatile float Pitch = 0.0f, 
			   Roll  = 0.0f, 
			   Yaw   = 0.0f;
// 欧拉角系数
const float roll_k  = 1.0f,
			pitch_k = 90.0f /85.0f,
			yaw_k   = 90.0f / 5.0f;

void Show_MPU6050_UI(void)
{
	OLED_ShowImage(0, 0, 16, 16, Return);
	OLED_ShowString(79, 0, "[校准]", OLED_8X16);
	OLED_Printf(0, 16, OLED_8X16, "Roll: %.2f", Roll  * roll_k);
	OLED_Printf(0, 32, OLED_8X16, "Pitch:%.2f", Pitch * pitch_k);
	OLED_Printf(0, 48, OLED_8X16, "Yaw:  %.2f", Yaw   * yaw_k);
}
/*******************************************************************************************************************/
/*[E] 界面样式 [E]-------------------------------------------------------------------------------------------------*/
/*******************************************************************************************************************/


/*******************************************************************************************************************/
/*[S] 零飘校准 [S]-------------------------------------------------------------------------------------------------*/
/*******************************************************************************************************************/

// 零飘校准目标样本数
#define CALI_TARGET_SAMPLES	500

// 零飘校准计数
static uint16_t Cali_count = 0;
// 零飘校准平均值
//static float ax_bias = 0.0f, ay_bias = 0.0f, az_bias = 0.0f;
static float gx_bias = 0.0f, gy_bias = 0.0f, gz_bias = 0.0f;

// 枚举定义动态校准状态
typedef enum {
    CALI_STATE_SPARE   = 0,     				// 未校准
    CALI_STATE_RUNNING = 1,   					// 校准中
    CALI_STATE_DONE    = 2       				// 已校准
} Cali_State_t;

static Cali_State_t cali_state = CALI_STATE_SPARE;

// MPU6050测得的三轴加速度和角速度原始数据
int16_t AX, AY, AZ, GX, GY, GZ;

//-------------------------------------------------------------------------------------------------------------------
// 函数简介     校准初始化并启动
//-------------------------------------------------------------------------------------------------------------------
void MPU6050_Calibration_Start(void)
{
	// 状态设为运行中
    cali_state = CALI_STATE_RUNNING;  
    Cali_count = 0;
    // 数据重置
//	ax_bias = ay_bias = az_bias = 0.0f;
	gx_bias = gy_bias = gz_bias = 0.0f;
	
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介     校准进程函数
// 返回参数 	返回校准状态（数字对应CCali_State_t的枚举定义）
// 返回参数		0 	未校准
// 返回参数 	1 	校准中
// 返回参数 	2 	已校准
//-------------------------------------------------------------------------------------------------------------------
uint8_t MPU6050_Calibration_Check(void)
{
	// 如果已校准，返回当前校准状态为2
    if(cali_state == CALI_STATE_DONE)
	{
        return 2;
    }
	
	// 如果未校准，返回当前校准状态为0
	if(cali_state == CALI_STATE_SPARE)
	{
        return 0;
    }
	
	// 是否可以统计数据
	if (MPU6050_ANALYSIS_ENABLE)
	{
		// 读取原始数据
		MPU6050_GetData(&AX, &AY, &AZ, &GX, &GY, &GZ);
		
		// 误差累计
		gx_bias += GX / 16.4f * (pi / 180.0f);
		gy_bias += GY / 16.4f * (pi / 180.0f);
		gz_bias += GZ / 16.4f * (pi / 180.0f);
		Cali_count ++;
		
		// 样本达标
		if (Cali_count >= CALI_TARGET_SAMPLES)
		{
			gx_bias = (float)gx_bias / CALI_TARGET_SAMPLES;
			gy_bias = (float)gy_bias / CALI_TARGET_SAMPLES;
			gz_bias = (float)gz_bias / CALI_TARGET_SAMPLES;
			
			cali_state = CALI_STATE_DONE;
		}
		
		MPU6050_ANALYSIS_ENABLE = 0;
	}
	
	// 如果在校准，返回当前校准状态为1
    return 1;
}

/*******************************************************************************************************************/
/*[E] 零飘校准 [E]-------------------------------------------------------------------------------------------------*/
/*******************************************************************************************************************/


/*******************************************************************************************************************/
/*[S] 姿态解算 [S]-------------------------------------------------------------------------------------------------*/
/*******************************************************************************************************************/

//-------------------------------------------------------------------------------------------------------------------
// 函数简介     欧拉角转四元数
// 备注信息     姿态解算固定过程调用
//-------------------------------------------------------------------------------------------------------------------
extern volatile float q0, q1, q2, q3;

void quat2euler(float q_0, float q_1, float q_2, float q_3,
				volatile float* phi, volatile float* theta, volatile float* psi)
{
    float R[3][3];
    R[0][0] = 1 - 2 * (q_2 * q_2 + q_3 * q_3);
    R[0][1] = 2 * (q_1 * q_2 - q_0 * q_3);
    R[0][2] = 2 * (q_0 * q_2 + q_1 * q_3);
    R[1][0] = 2 * (q_1 * q_2 + q_0 * q_3);
    R[1][1] = 1 - 2 * (q_1 * q_1 + q_3 * q_3);
    R[1][2] = 2 * (q_2 * q_3 - q_0 * q_1);
    R[2][0] = 2 * (q_1 * q_3 - q_0 * q_2);
    R[2][1] = 2 * (q_0 * q_1 + q_2 * q_3);
    R[2][2] = 1 - 2 * (q_1 * q_1 + q_2 * q_2);

    *phi   = atan2( R[2][1], R[2][2]);
    *theta = asin (-R[2][0]);
    *psi   = atan2( R[1][0], R[0][0]);
	
	*phi   = *phi   * 180.0f / pi;
    *theta = *theta * 180.0f / pi;
    *psi   = *psi   * 180.0f / pi;
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介     姿态解算整合
//-------------------------------------------------------------------------------------------------------------------
void MPU6050_Calculation(void)
{
	MPU6050_GetData(&AX, &AY, &AZ, &GX, &GY, &GZ);
	
	// 标准单位计算得的三轴加速度和角速度结果
	float ax, ay, az, gx, gy, gz;
	
	ax = AX / 2048.0f;
	ay = AY / 2048.0f;
	az = AZ / 2048.0f;
	
	gx = (GX / 16.4f) * (pi / 180.0f) - gx_bias;
	gy = (GY / 16.4f) * (pi / 180.0f) - gy_bias;
	gz = (GZ / 16.4f) * (pi / 180.0f) - gz_bias;
	
	MahonyAHRSupdateIMU(gx, gy, gz, ax, ay, az);
	
	quat2euler(q0, q1, q2, q3, &Roll, &Pitch, &Yaw); 
}

/*******************************************************************************************************************/
/*[E] 姿态解算 [E]-------------------------------------------------------------------------------------------------*/
/*******************************************************************************************************************/

// MPU6050界面选项标志位
uint8_t mpu6050_flag = 1;

// 控制光标在MPU6050界面移动的函数
int MPU6050(void)
{
	OLED_Clear();
	Show_MPU6050_UI();
	OLED_ReverseArea(0, 0, 16, 16);	
	OLED_Update();
	

	/* mpu6050零飘校准逻辑(此时请保持静止)*/
	if (MPU6050_Calibration_Check() != 2)// 如果未校准
	{
		MPU6050_Calibration_Start();	
		OLED_ShowString(79, 0, "校准中", OLED_8X16);
		OLED_Update();
	}
	// 半阻塞式零飘校准
	while(1)  
	{
		if (MPU6050_Calibration_Check() == 2)  // 零飘校准完成
		{
			break;  // 跳出零飘校准循环，往下执行
		}       
		// 可以考虑在这里操作OLED，但也请注意时间占用
		
		// 强制零飘校准退出
		if(Key_Check(KEY_NAME_COMFIRM,KEY_SINGLE))
		{
			break;  // 退出零飘校准模式
		}
	}
	
	
	
	while(1)
	{
		// 存储确认键被按下时mpu6050_flag的值的临时变量，默认为无效值0
		uint8_t mpu6050_flag_temp = 0;
		
		/* 按键处理*/
		if (Key_Check(KEY_NAME_UP,KEY_SINGLE))// 上键
		{
			mpu6050_flag --;
			if (mpu6050_flag < 1)mpu6050_flag = 2;
		}
		else if (Key_Check(KEY_NAME_DOWN,KEY_SINGLE))// 下键
		{
			mpu6050_flag ++;
			if (mpu6050_flag > 2)mpu6050_flag = 1;
		}
		else if(Key_Check(KEY_NAME_COMFIRM,KEY_SINGLE))// 确认键
		{
			mpu6050_flag_temp = mpu6050_flag;
		}
		
		/* 功能跳转*/
		// 返回上一级菜单
		if (mpu6050_flag_temp == 1){OLED_Clear();OLED_Update();return 0;}
		// 进行校准
		if (mpu6050_flag_temp == 2)
		{
			OLED_ShowString(79, 0, "校准中", OLED_8X16);
			OLED_Update();
	
			/* mpu6050零飘校准逻辑(此时请保持静止)*/
			MPU6050_Calibration_Start();			
			// 半阻塞式零飘校准
			while(1)  
			{
				if (MPU6050_Calibration_Check() == 2)  // 零飘校准完成
				{
					break;  // 跳出零飘校准循环，往下执行
				}				
				// 可以考虑在这里操作OLED，但也请注意时间占用
				
				// 强制零飘校准退出
				if(Key_Check(KEY_NAME_COMFIRM,KEY_SINGLE))
				{
					break;  // 退出零飘校准模式
				}       
			}
		}
		
		/* 姿态解算*/
		if (MPU6050_ANALYSIS_ENABLE)
		{
			MPU6050_Calculation();
			MPU6050_ANALYSIS_ENABLE = 0;
		}
		
		/* 显示更新*/
		switch(mpu6050_flag)
		{
			// 光标在"回车"键
			case 1:
				OLED_Clear();
				Show_MPU6050_UI();
				OLED_ReverseArea(0, 0, 16, 16);
				OLED_Update();
			
				break;
			
			// 光标在"校准"键
			case 2:
				OLED_Clear();
				Show_MPU6050_UI();
				OLED_ReverseArea(79, 0, 48, 16);
				OLED_Update();
			
				break;
		}
	}
}
